/*++

Module Name:

	device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.

Environment:

	User-mode Driver Framework 2

--*/

#include "driver.h"
#include "device.tmh"

#include <DmfModules.Library.h>

EVT_DMF_DEVICE_MODULES_ADD DmfDeviceModulesAdd;


NTSTATUS
dshidminiCreateDevice(
	_Inout_ PWDFDEVICE_INIT DeviceInit
)
/*++

Routine Description:

	Worker routine called to create a device and its software resources.

Arguments:

	DeviceInit - Pointer to an opaque init structure. Memory for this
					structure will be freed by the framework when the WdfDeviceCreate
					succeeds. So don't access the structure after that point.

Return Value:

	NTSTATUS

--*/
{
	WDF_OBJECT_ATTRIBUTES deviceAttributes;
	PDEVICE_CONTEXT deviceContext;
	WDFDEVICE device;
	NTSTATUS status;
	NTSTATUS ntStatus;
	PDMFDEVICE_INIT dmfDeviceInit;
	DMF_EVENT_CALLBACKS dmfCallbacks;


	dmfDeviceInit = DMF_DmfDeviceInitAllocate(DeviceInit);

	// All DMF drivers must call this function even if they do not support PnP Power callbacks.
	// (In this case, this driver does support a PnP Power callback.)
	//
	DMF_DmfDeviceInitHookPnpPowerEventCallbacks(dmfDeviceInit,
		NULL);

	// All DMF drivers must call this function even if they do not support File Object callbacks.
	//
	DMF_DmfDeviceInitHookFileObjectConfig(dmfDeviceInit,
		NULL);

	// All DMF drivers must call this function even if they do not support Power Policy callbacks.
	//
	DMF_DmfDeviceInitHookPowerPolicyEventCallbacks(dmfDeviceInit,
		NULL);

	// This is a filter driver that loads on MSHIDUMDF driver.
	//
	WdfFdoInitSetFilter(DeviceInit);
	// DMF Client drivers that are filter drivers must also make this call.
	//
	DMF_DmfFdoSetFilter(dmfDeviceInit);


	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

	if (NT_SUCCESS(status)) {

		// Create the DMF Modules this Client driver will use.
		//
		dmfCallbacks.EvtDmfDeviceModulesAdd = DmfDeviceModulesAdd;
		DMF_DmfDeviceInitSetEventCallbacks(dmfDeviceInit,
			&dmfCallbacks);

		ntStatus = DMF_ModulesCreate(device,
			&dmfDeviceInit);
		if (!NT_SUCCESS(ntStatus))
		{
			goto Exit;
		}

		//
		// Get a pointer to the device context structure that we just associated
		// with the device object. We define this structure in the device.h
		// header file. DeviceGetContext is an inline function generated by
		// using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
		// This function will do the type checking and return the device context.
		// If you pass a wrong object handle it will return NULL and assert if
		// run under framework verifier mode.
		//
		deviceContext = DeviceGetContext(device);

		//
		// Initialize the context.
		//
		deviceContext->PrivateDeviceData = 0;
	}

Exit:

	if (dmfDeviceInit != NULL)
	{
		DMF_DmfDeviceInitFree(&dmfDeviceInit);
	}

	return status;
}

#pragma code_seg("PAGED")
_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
DmfDeviceModulesAdd(
	_In_ WDFDEVICE Device,
	_In_ PDMFMODULE_INIT DmfModuleInit
)
/*++

Routine Description:

	Add all the DMF Modules used by this driver.

Arguments:

	Device - WDFDEVICE handle.
	DmfModuleInit - Opaque structure to be passed to DMF_DmfModuleAdd.

Return Value:

	NTSTATUS

--*/
{
	PDEVICE_CONTEXT deviceContext;
	DMF_MODULE_ATTRIBUTES moduleAttributes;
	//DMF_CONFIG_VirtualHidMiniSample moduleConfigVirtualHidDeviceMiniSample;

	UNREFERENCED_PARAMETER(deviceContext);
	UNREFERENCED_PARAMETER(moduleAttributes);
	UNREFERENCED_PARAMETER(DmfModuleInit);

	UNREFERENCED_PARAMETER(Device);

	PAGED_CODE();

	//deviceContext = DeviceContextGet(Device);

	// VirtualHidDeviceMiniSample
	// --------------------------
	//
	//DMF_CONFIG_VirtualHidMiniSample_AND_ATTRIBUTES_INIT(&moduleConfigVirtualHidDeviceMiniSample,
	//    &moduleAttributes);
	//DMF_DmfModuleAdd(DmfModuleInit,
	//    &moduleAttributes,
	//    WDF_NO_OBJECT_ATTRIBUTES,
	//    &deviceContext->DmfModuleVirtualHidDeviceMiniSample);
}
#pragma code_seg()


